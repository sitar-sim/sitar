{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"index.html","title":"Sitar Simulation Framework","text":"<p>Sitar is a framework for modeling and parallel simulation of synchronous (clocked) discrete-event systems.  </p> <p>It combines a domain-specific modeling language with a lightweight C++ simulation kernel, enabling deterministic and scalable simulation of tightly synchronized systems.</p>"},{"location":"index.html#target-applications","title":"Target Applications","text":"<p>Sitar is ideally suited for modeling large and complex synchronous systems with a static interconnection structure, particularly in domains where system behavior is naturally expressed at discrete time-steps and where scalability and determinism in simulation are critical. Typical application areas include:</p> <ul> <li>System-level and computer architecture research models, such as multi-core processors, memory hierarchies, interconnects, and on-chip networks, where components interact synchronously on a global clock.</li> <li>Computer and communication networks, including packet-switched networks, mesh and torus topologies, and network-on-chip (NoC) models, where communication latency and buffering semantics are explicitly modeled.</li> <li>Discrete-time queueing networks, where arrivals, services, and routing decisions occur at fixed time intervals and system state evolves synchronously across components.</li> </ul> <p>By restricting the modeling scope to this class of systems, Sitar enables a simple and efficient simulation algorithm that scales well with model size, while remaining expressive enough for writing very large, complex models.</p> <p>Scalability and Performance</p> <p>In single-threaded execution, Sitar\u2019s performance is comparable to that of SystemC. When parallel execution is enabled, speedups of up to 50\u00d7 have been observed on a 40-core shared-memory system for large, compute-intensive models.</p>"},{"location":"index.html#core-idea","title":"Core Idea","text":"<ul> <li>Sitar models a system as a collection of Modules that communicate via Nets (FIFO channels) and evolve in discrete logical time. Each simulation cycle is divided into two phases: a read phase, in which nets may only be read from, and a write phase, in which nets may only be written to. This restriction enforces race-free and deterministic execution, and enables parallel simulation by mapping individual modules to separate execution threads that synchronize only at the end of each phase, eliminating the need for explicit dependency analysis in the system. A direct consequence of this design is that communication over nets incurs a minimum latency of one clock cycle, which is natural for target application domains such as computer architecture and system-level modeling.</li> </ul> <ul> <li>Sitar also provides a modeling language that has a rich set of constructs for describing system structure and interconnections, as well as module behavior in a sequential manner, including fork\u2013join parallelism (using parallel blocks), wait statements, and control-flow constructs such as loops (do-while) and conditionals (if-else). Parallel blocks can be used to model concurrent components that require zero-latency interaction, grouped within a single module and executed on the same thread with a fixed, deterministic ordering. Raw C++ code can be embedded into the description in well-defined ways, within dollar symbols (<code>$...$</code>).</li> </ul> <ul> <li> <p>Each module description is translated into highly readable C++ code as a class with the behavior translated as lightweight state-machine code implemented using a case-statement with explicit activity pointers, conceptually similar to coroutines in C++ or generator functions in Python. This design allows users to focus on system structure and behavior, while the framework manages time advancement, scheduling, and deterministic parallel execution.</p> </li> <li> <p>The simulation kernel itself is intentionally simple and lightweight. This makes it easy to co-simulate Sitar models with external simulation environments, by advancing the Sitar model using explicit clock ticks (one per phase, i.e., two per simulation cycle).</p> </li> </ul>"},{"location":"index.html#toolchain-overview","title":"Toolchain Overview","text":"<p>A Sitar model is written using the Sitar modeling language and processed through a simple toolchain:</p> <ul> <li> The model is translated into readable C++ code.</li> <li> The generated code is compiled together with the simulation kernel.</li> <li> The resulting executable is run in serial or parallel mode.</li> </ul> <p>Parallel execution is supported via OpenMP and can be enabled without modifying the model itself.</p>"},{"location":"index.html#publications-and-slides","title":"Publications and Slides","text":"<p>To learn more about the design and applications of Sitar, see the following resources:</p> <ol> <li> <p>SIMULTECH 2022 (Best Paper Award)    Foundational paper introducing Sitar and its parallel simulation approach. <code>download pdf</code></p> </li> <li> <p>Winter Simulation Conference 2024    Detailed description of the execution model and performance evaluation. <code>download pdf</code></p> </li> <li> <p>Tutorial Slides    Overview of key ideas, modeling constructs, and execution semantics. <code>download pdf</code></p> </li> </ol>"},{"location":"index.html#reopsitory-and-license","title":"Reopsitory and License","text":"<p>Sitar's Github Repository: <code>https://github.com/sitar-sim/sitar</code></p> <p>Sitar is released under the MIT License. See the <code>LICENSE</code> file in the repository for details.</p>"},{"location":"404.html","title":"404: Page not found","text":"<p>The requested page is not available at the moment.</p> <p>The Sitar documentation is currently being incrementally revised and expanded, and some sections may not yet be written, published or fully linked. We apologize for any inconvenience this may cause.</p> <p>Please use the navigation sidebar to access available sections, or return to the homepage.</p> <p>Go to homepage</p>"},{"location":"examples.html","title":"Examples","text":""},{"location":"examples.html#waiting-semantics","title":"Waiting semantics","text":"<p>The following example shows phase vs cycle waiting:</p> <p>Sitar: <pre><code>//print Hello World \n\nmodule Top\n\n    behavior\n    $log&lt;&lt;endl&lt;&lt;\"Hello World!!\";$;\n    end behavior\nend module\n</code></pre></p> <p>Sitar: <pre><code>//Wait statements\n\nmodule Top\n    //wait\n    submodule a : Wait \nend module\n\nmodule Wait\n\n    behavior\n    $cout&lt;&lt;\"\\n time = \"&lt;&lt;current_time;$;\n    wait; //wait for one phase. Same as wait (0,1).\n    $cout&lt;&lt;\"\\n time = \"&lt;&lt;current_time;$;\n\n    wait(2,0); //wait two cycles\n    $cout&lt;&lt;\"\\n time = \"&lt;&lt;current_time;$;\n\n    wait(3,1); //wait 3 cycles and one phase\n    $cout&lt;&lt;\"\\n time = \"&lt;&lt;current_time;$;\n\n    wait until (current_time==time(10,0));\n    //wait until expression evaluates to true\n     $cout&lt;&lt;\"\\n time = \"&lt;&lt;current_time;$;\n    end behavior\nend module\n</code></pre> Sitar: <pre><code>//A Shift register consists of a\n//producer, connected to a consumer through \n//an array of shift register stages.\n//The number of stages and delay of \n//each stage are parameters\n\nmodule Top\n    submodule S : ShiftRegister&lt;3,2&gt; \n    //Instantiate a shift register with &lt;num_stages=3,delay=2&gt;\nend module\n\nmodule ShiftRegister \n    parameter int N = 1     //number of stages\n    parameter int DELAY = 1 //delay of each stage\n\n    submodule p : Producer\n    submodule c : Consumer\n    submodule_array stage[N]  : Stage&lt;DELAY&gt;\n    net_array n[N+1] : capacity 1\n\n    //make connections\n    for i in 0 to (N - 1)\n        stage[i].ip &lt;= n[i]\n        stage[i].op =&gt; n[i+1]\n    end for\n    p.op =&gt; n[0]\n    c.ip &lt;= n[N]\nend module\n\nmodule Stage\n    parameter   int     DELAY = 1  //delay of each stage\n    inport      ip  \n    outport     op  \n    decl $token&lt;&gt; t; bool done_pull; bool done_push;$\nbehavior\n    do\n        //pull a token\n        $done_pull=0;$;\n        do\n            wait until (this_phase==0);\n            $done_pull=ip.pull(t);$;\n            if(not done_pull) then wait end if;\n        while(not done_pull) end do;\n        $\n        {\n        cout&lt;&lt;\"\\n\"&lt;&lt;std::setw(12)&lt;&lt;hierarchicalId();\n        cout&lt;&lt;\"\\t pulled a token with ID \"&lt;&lt;t.ID;\n        cout&lt;&lt;\" at time \"&lt;&lt;current_time;\n        }$;\n\n        wait(DELAY,0);\n\n        $done_push=0;$;\n        do\n            wait until (this_phase==1);\n            $done_push=op.push(t);$;\n            if(not done_push) then wait end if;\n        while(not done_push) end do;\n        $\n        {\n        cout&lt;&lt;\"\\n\"&lt;&lt;std::setw(12)&lt;&lt;hierarchicalId();\n        cout&lt;&lt;\"\\t pushed a token with ID \"&lt;&lt;t.ID;\n        cout&lt;&lt;\" at time \"&lt;&lt;current_time;\n        }$;\n    while(1) end do;\nend behavior\nend module\n\nmodule Producer\n    outport op \n    decl $token&lt;&gt; t; int count;$\n    decl $static const int num_tokens=5;$ //total number of tokens produced\nbehavior \n    init$ count=0;$;\n    do\n        wait until (this_phase==1);\n        //try to output as many tokens as possible\n        $\n        t.ID=count;\n        while(op.push(t))\n        {\n            cout&lt;&lt;\"\\n\"&lt;&lt;std::setw(12)&lt;&lt;hierarchicalId();\n            cout&lt;&lt;\"\\t pushed a token with ID \"&lt;&lt;t.ID;\n            cout&lt;&lt;\" at time \"&lt;&lt;current_time;\n            count ++;\n            t.ID=count;\n            if(count&gt;=num_tokens) break;\n        }\n        $;\n        wait;\n    while (count&lt;num_tokens) end do;\nend behavior\nend module\n\nmodule Consumer\n    inport ip \n    decl $token&lt;&gt; t; int count;$\nbehavior \n    init$ count=0;$;\n    do\n        wait until (this_phase==0);\n        //try to pull as many tokens as possible\n\n        $\n        while(ip.pull(t))\n        {\n            cout&lt;&lt;\"\\n\"&lt;&lt;std::setw(12)&lt;&lt;hierarchicalId();\n            cout&lt;&lt;\"\\t pulled a token with ID \"&lt;&lt;t.ID;\n            cout&lt;&lt;\" at time \"&lt;&lt;current_time;\n            count ++;\n        }\n        $;\n        wait;\n    while (1) end do;\nend behavior\nend module\n</code></pre></p> <p>Inline: This <code>//hey $hi$</code> is an example of an inline sitar code </p> <p>You can temporarily disable the snippet by placing a ; before the file name:</p>"}]}